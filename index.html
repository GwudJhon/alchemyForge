<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Click to X Grid</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        .next-elements-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }
        .next-element {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background-color: #222;
            border-radius: 4px;
            border: 2px solid #555;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 1px;
            background-color: black;
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        .grid-cell {
            position: relative;
            border: 1px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 50px;
            cursor: pointer;
            background-color: #111;
            color: white;
            font-size: 24px;
            aspect-ratio: 1;
            transition: background-color 0.2s;
        }
        .grid-cell:hover {
            background-color: #222;
        }
        .bonus {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 10px;
            color: gold;
            font-weight: bold;
            text-shadow: 0 0 2px black;
        }
        h1 {
            margin-bottom: 20px;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="next-elements-container" id="nextElements"></div>
    <div class="grid-container" id="mainGrid"></div>

    <script>
        const gridSize = 6;
        let mainGrid = []; // Will store {type, bonus} objects
        let isAnimating = false; // Animation lock flag
        const ELEMENTS = {
            EMPTY: '',
            A: 'ðŸŸ«',
            B: 'ðŸŸ¥',
            C: 'ðŸŸ¢',
            D: 'ðŸŸ¡',
            E: 'ðŸ”¶',
            F: 'ðŸ”·'
        };
        
        // Define the progression order
        const ELEMENT_PROGRESSION = [
            ELEMENTS.A,
            ELEMENTS.B,
            ELEMENTS.C,
            ELEMENTS.D,
            ELEMENTS.E,
            ELEMENTS.F
        ];
        
        const MinConnections = 5;

        // Initialize the grid
        function initializeGrid() {
            const gridDiv = document.getElementById('mainGrid');
            const nextElementsDiv = document.getElementById('nextElements');

            gridDiv.innerHTML = '';
            nextElementsDiv.innerHTML = ''; // Clear previous elements
            
            // Create empty grid structure
            for (let i = 0; i < gridSize; i++) {
                mainGrid[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    mainGrid[i][j] = {
                        type: ELEMENTS.EMPTY,
                        bonus: 0
                    };
                    
                    // Create cell element
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    cell.addEventListener('click', function() {
                        toggleX(i, j, cell);
                    });
                    
                    gridDiv.appendChild(cell);
                }
            }
            for (let i = 0; i < 3; i++) {
                const nextElement = document.createElement('div');
                nextElement.className = 'grid-cell';
                nextElement.textContent = ELEMENTS.A;
                nextElementsDiv.appendChild(nextElement);
            }

            initializeNextElements();
        }

        // Get the next element in progression
        function getNextElement(currentElement) {
            const currentIndex = ELEMENT_PROGRESSION.indexOf(currentElement);
            if (currentIndex === -1 || currentIndex === ELEMENT_PROGRESSION.length - 1) {
                return currentElement; // No progression possible
            }
            return ELEMENT_PROGRESSION[currentIndex + 1];
        }

        function nextElements(){
            const nextElementsDiv = document.getElementById('nextElements');
            nextElementsDiv.innerHTML = ''; // Clear previous elements
        }

        // Update cell display with symbol and bonus
        function updateCell(row, col) {
            const cellEl = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
            const cellData = mainGrid[row][col];
            
            cellEl.textContent = cellData.type;
            
            // Clear existing bonus display
            const existingBonus = cellEl.querySelector('.bonus');
            if (existingBonus) {
                cellEl.removeChild(existingBonus);
            }
            
            // Add bonus if exists
            if (cellData.bonus > 0) {
                const bonusEl = document.createElement('span');
                bonusEl.className = 'bonus';
                bonusEl.textContent = `+${cellData.bonus}`;
                cellEl.appendChild(bonusEl);
            }
        }

        function getHighestUnlockedElementIndex() {
            let maxIndex = -1;
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const type = mainGrid[row][col].type;
                    const index = ELEMENT_PROGRESSION.indexOf(type);
                    if (index > maxIndex) {
                        maxIndex = index;
                    }
                }
            }
            return maxIndex;
        }


        // Generate next elements with weighted probabilities
        function getRandomElement() {
            const highestUnlockedIndex = getHighestUnlockedElementIndex();
            const possibleElements = [];

            // Start with newest element having base weight
            if (highestUnlockedIndex >= 0) {
                possibleElements.push({
                    element: ELEMENT_PROGRESSION[highestUnlockedIndex],
                    weight: 5
                });
            } else {
                // First ever element
                return ELEMENT_PROGRESSION[0];
            }

            // Add older elements with increasing weights
            let currentWeight = 5;
            for (let i = highestUnlockedIndex - 1; i >= 0; i--) {
                currentWeight *= 2;
                possibleElements.push({
                    element: ELEMENT_PROGRESSION[i],
                    weight: currentWeight
                });
            }

            // Normalize weights
            const totalWeight = possibleElements.reduce((sum, el) => sum + el.weight, 0);
            // set the last value in possibleElements[] to be equal to totalWeight
            possibleElements[possibleElements.length - 1].weight += 100 - totalWeight;
            rand = Math.random() * 100; // Random number between 0 and 100
            console.log(JSON.stringify(possibleElements, null, 2)); // Debugging output
            console.log('Picked value: ' + rand); // Debugging output
            // pick the element that has the rand number in its weight range
            let cumulativeWeight = 0;
            for (let i = 0; i < possibleElements.length; i++) {
                cumulativeWeight += possibleElements[i].weight;
                if (rand <= cumulativeWeight) {
                    console.log('Picked element: ' + possibleElements[i].element); // Debugging output
                    return possibleElements[i].element;
                }
            }

            console.log(JSON.stringify(possibleElements, null, 2)); // Debugging output
            

            return ELEMENT_PROGRESSION[0]; // Fallback
        }



        // Initialize and display next elements
        function initializeNextElements() {
            nextElementsQueue = [
                getRandomElement(),
                getRandomElement(),
                getRandomElement()
            ];
            updateNextElementsDisplay();
        }

        // Update the visual display of next elements
        function updateNextElementsDisplay() {
            const nextElementsDiv = document.getElementById('nextElements');
            nextElementsDiv.innerHTML = '';
            
            nextElementsQueue.forEach(element => {
                const el = document.createElement('div');
                el.className = 'next-element';
                el.textContent = element;
                nextElementsDiv.appendChild(el);
            });
        }

        // Get the next element to place and refill the queue
        function getNextElementToPlace() {
            const elementToPlace = nextElementsQueue[0];
            
            // Shift the queue and add a new element
            nextElementsQueue.shift();
            nextElementsQueue.push(getRandomElement());
            
            updateNextElementsDisplay();
            return elementToPlace;
        }

        // Toggle X in a cell
        function toggleX(row, col, cellElement) {
            if (isAnimating) return; // Prevent clicks during animation
            if (mainGrid[row][col].type === ELEMENTS.EMPTY) {
                const elementToPlace = getNextElementToPlace();
                mainGrid[row][col] = {
                    type: elementToPlace,  // Start with first element
                    bonus: 0
                };
                updateCell(row, col);
                checkPossibleMerges(row, col, elementToPlace); 
            } 
        }

        // Check for possible merges
        function checkPossibleMerges(startRow, startCol, ELEMENT) {
            isAnimating = false; // Unlock animation
            if (mainGrid[startRow][startCol].type !== ELEMENT) return;

            const visited = new Set();
            const queue = [{ row: startRow, col: startCol }];
            const connected = [];

            while (queue.length > 0) {
                const { row, col } = queue.shift();
                const key = `${row},${col}`;
                if (visited.has(key)) continue;

                visited.add(key);
                connected.push({ row, col });

                const directions = [
                    { r: -1, c: 0 }, // Up
                    { r: 1, c: 0 },  // Down
                    { r: 0, c: -1 }, // Left
                    { r: 0, c: 1 }   // Right
                ];

                for (let dir of directions) {
                    const newRow = row + dir.r;
                    const newCol = col + dir.c;

                    if (
                        newRow >= 0 && newRow < gridSize &&
                        newCol >= 0 && newCol < gridSize &&
                        mainGrid[newRow][newCol].type === ELEMENT &&
                        !visited.has(`${newRow},${newCol}`)
                    ) {
                        queue.push({ row: newRow, col: newCol });
                    }
                }
            }

            if (connected.length >= MinConnections) {
                isAnimating = true; // Lock animation
                // Calculate total bonus from all merged cells
                let totalBonus = connected.reduce((sum, {row, col}) => {
                    return sum + mainGrid[row][col].bonus;
                }, 0);
                
                // Additional bonus from extra connections
                totalBonus += connected.length - MinConnections;

                // First pass: Clear all cells (starting from end)
                connected.slice().reverse().forEach(({ row, col }, index) => {
                    setTimeout(() => {
                        mainGrid[row][col] = {
                            type: ELEMENTS.EMPTY,
                            bonus: 0
                        };
                        updateCell(row, col);
                    }, index * 100);
                });

                // Second pass: Convert first cell after all clears finish
                setTimeout(() => {
                    const first = connected[0];
                    const newType = getNextElement(ELEMENT);

                    mainGrid[first.row][first.col] = {
                        type: newType,
                        bonus: totalBonus
                    };
                    updateCell(first.row, first.col);
                    
                    // Check for new possible merges (unless it's the final element)
                    if (ELEMENT_PROGRESSION.indexOf(newType) < ELEMENT_PROGRESSION.length - 1) {
                        checkPossibleMerges(first.row, first.col, newType);
                    }
                }, connected.length * 100);
            }
        }

        // Initialize on page load
        initializeGrid();
    </script>
</body>
</html>
