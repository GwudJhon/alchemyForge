<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Click to X Grid</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        .next-elements-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }
        .next-element {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background-color: #222;
            border-radius: 4px;
            border: 2px solid #555;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 1px;
            background-color: black;
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        .grid-cell {
            position: relative;
            border: 1px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 50px;
            cursor: pointer;
            background-color: #111;
            color: white;
            font-size: 24px;
            aspect-ratio: 1;
            transition: background-color 0.2s;
        }
        .grid-cell:hover {
            background-color: #222;
        }
        .bonus {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 10px;
            color: gold;
            font-weight: bold;
            text-shadow: 0 0 2px black;
        }
        h1 {
            margin-bottom: 20px;
            color: #333;
        }
        @keyframes lightBobble {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }
        @keyframes strongBobble {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }
        .bobble-light {
            animation: lightBobble 0.5s infinite ease-in-out;
        }
        .bobble-strong {
            animation: strongBobble 0.4s infinite ease-in-out;
        }

        /* Random sparkle generator */
        @keyframes sparkle-fade {
        0% { opacity: 0; transform: scale(0.3); }
        20% { opacity: 1; }
        100% { opacity: 0; transform: scale(1.2); }
        }

        .cell-with-bonus {
        position: relative;
        overflow: hidden;
        }

        .sparkle {
        position: absolute;
        font-size: 12px;
        pointer-events: none;
        animation: sparkle-fade 1.5s ease-out infinite;
        opacity: 0;
        }

        /* Generate multiple sparkle elements with random delays */
        .sparkle:nth-child(1) { animation-delay: 0.3s; }
        .sparkle:nth-child(2) { animation-delay: 1.1s; }
        .sparkle:nth-child(3) { animation-delay: 0.7s; }
        .sparkle:nth-child(4) { animation-delay: 1.4s; }
        .sparkle:nth-child(5) { animation-delay: 2s; }
    </style>
</head>
<body>
    <div class="next-elements-container" id="nextElements"></div>
    <div class="grid-container" id="mainGrid"></div>

    <script>
        const gridSize = 6;
        let mainGrid = []; // Will store {type, bonus} objects
        let isAnimating = false; // Animation lock flag
        const ELEMENTS = {
            EMPTY: '',
            A: '🟫',
            B: '🟥',
            C: '🟢',
            D: '🟡',
            E: '🔶',
            F: '🔷'
        };
        
        // Define the progression order
        const ELEMENT_PROGRESSION = [
            ELEMENTS.A,
            ELEMENTS.B,
            ELEMENTS.C,
            ELEMENTS.D,
            ELEMENTS.E,
            ELEMENTS.F
        ];
        
        const MinConnections = 5;

        // Initialize the grid
        function initializeGrid() {
            const gridDiv = document.getElementById('mainGrid');
            const nextElementsDiv = document.getElementById('nextElements');

            gridDiv.innerHTML = '';
            nextElementsDiv.innerHTML = ''; // Clear previous elements
            
            // Create empty grid structure
            for (let i = 0; i < gridSize; i++) {
                mainGrid[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    if (i < 4 && j === 0) {
                        mainGrid[i][j] = {
                            type: ELEMENTS.D,
                            bonus: 0
                        };
                    } else {
                        mainGrid[i][j] = {
                            type: ELEMENTS.EMPTY,
                            bonus: 0
                        };
                    }
                    
                    // Create cell element
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    cell.addEventListener('click', function() {
                        toggleX(i, j, cell);
                    });
                    
                    gridDiv.appendChild(cell);
                }
            }
            for (let i = 0; i < 3; i++) {
                const nextElement = document.createElement('div');
                nextElement.className = 'grid-cell';
                nextElement.textContent = ELEMENTS.A;
                nextElementsDiv.appendChild(nextElement);
            }

            initializeNextElements();
        }

        // Get the next element in progression
        function getNextElement(currentElement) {
            const currentIndex = ELEMENT_PROGRESSION.indexOf(currentElement);
            if (currentIndex === -1 || currentIndex === ELEMENT_PROGRESSION.length - 1) {
                return currentElement; // No progression possible
            }
            return ELEMENT_PROGRESSION[currentIndex + 1];
        }

        function nextElements(){
            const nextElementsDiv = document.getElementById('nextElements');
            nextElementsDiv.innerHTML = ''; // Clear previous elements
        }

        // Update cell display with symbol and bonus
        function updateCell(row, col) {
            const cellEl = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
            const cellData = mainGrid[row][col];
            
            // Clear existing content
            cellEl.innerHTML = '';
            cellEl.className = 'grid-cell';
            cellEl.textContent = cellData.type;

            // Add bonus display
            if (cellData.bonus > 0) {
                cellEl.classList.add('cell-with-bonus');
                
                // Bonus text
                const bonusEl = document.createElement('span');
                bonusEl.className = 'bonus';
                bonusEl.textContent = `+${cellData.bonus}`;
                cellEl.appendChild(bonusEl);

                // Add random sparkles
                const sparkleCount = Math.min(3 + Math.floor(cellData.bonus / 2), 8); // 3-8 sparkles based on bonus
                for (let i = 0; i < sparkleCount; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle';
                sparkle.textContent = ['✨', '⭐', '⚡', '❄', '♡', '✦'][Math.floor(Math.random() * 6)];
                
                // Random positioning
                sparkle.style.left = `${Math.random() * 80 + 10}%`;
                sparkle.style.top = `${Math.random() * 80 + 10}%`;
                
                // Random size and animation duration
                sparkle.style.fontSize = `${8 + Math.random() * 10}px`;
                sparkle.style.animationDuration = `${1 + Math.random() * 2}s`;
                
                cellEl.appendChild(sparkle);
                }
            }
        }

        function getHighestUnlockedElementIndex() {
            let maxIndex = -1;
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const type = mainGrid[row][col].type;
                    const index = ELEMENT_PROGRESSION.indexOf(type);
                    if (index > maxIndex) {
                        maxIndex = index;
                    }
                }
            }
            return maxIndex;
        }

        function possibleElementsFunc() {
            const highestUnlockedIndex = getHighestUnlockedElementIndex();
            const possibleElements = [];

            // If no elements are placed yet, return just the first element
            if (highestUnlockedIndex === -1) {
                return [{ element: ELEMENT_PROGRESSION[0], weight: 100 }];
            }

            // Start with newest element having base weight
            possibleElements.push({
                element: ELEMENT_PROGRESSION[highestUnlockedIndex],
                weight: 5
            });

            // Add older elements with increasing weights
            let currentWeight = 5;
            for (let i = highestUnlockedIndex - 1; i >= 0; i--) {
                currentWeight *= 2;
                possibleElements.push({
                    element: ELEMENT_PROGRESSION[i],
                    weight: currentWeight
                });
            }

            // Normalize weights to sum to 100
            const totalWeight = possibleElements.reduce((sum, el) => sum + el.weight, 0);
            const remainingWeight = 100 - totalWeight;
            
            // Add remaining weight to the last (oldest) element
            if (possibleElements.length > 0) {
                possibleElements[possibleElements.length - 1].weight += remainingWeight;
            }

            if (possibleElements.length > 1){
                if (possibleElements[possibleElements.length - 1].weight < possibleElements[possibleElements.length - 2].weight) {
                    possibleElements[possibleElements.length - 2].weight += possibleElements[possibleElements.length - 1].weight;

                    // since after the pop the element will never appear again, automatically convert all of the same element on the main grid to the next one in the progression
                    for (let row = 0; row < gridSize; row++) {
                        for (let col = 0; col < gridSize; col++) {
                            if (mainGrid[row][col].type === possibleElements[possibleElements.length - 1].element) {
                                mainGrid[row][col].type = getNextElement(possibleElements[possibleElements.length - 1].element);
                                updateCell(row, col);
                            }
                        }
                    }

                    possibleElements.pop();

                    
                }
            }

            return possibleElements; // <-- This was missing!
        }

        function updateGrid(){
            console.log('Updating grid...');

            let possibleElements = possibleElementsFunc();

            console.log(JSON.stringify(possibleElements, null, 2)); // Debugging output
        }


        // Generate next elements with weighted probabilities
        function getRandomElement() {
            const possibleElements = possibleElementsFunc();
            updateGrid();
            rand = Math.floor(Math.random() * 100); // Random integer between 0 and 99
            console.log(JSON.stringify(possibleElements, null, 2)); // Debugging output
            console.log('Picked value: ' + rand); // Debugging output
            // pick the element that has the rand number in its weight range
            let cumulativeWeight = 0;
            for (let i = 0; i < possibleElements.length; i++) {
                cumulativeWeight += possibleElements[i].weight;
                if (rand <= cumulativeWeight) {
                    console.log('Picked element: ' + possibleElements[i].element); // Debugging output
                    return possibleElements[i].element;
                }
            }

            console.log(JSON.stringify(possibleElements, null, 2)); // Debugging output
            

            return ELEMENT_PROGRESSION[0]; // Fallback
        }



        // Initialize and display next elements
        function initializeNextElements() {
            nextElementsQueue = [
                getRandomElement(),
                getRandomElement(),
                getRandomElement()
            ];
            updateNextElementsDisplay();
        }

        // Update the visual display of next elements
        function updateNextElementsDisplay() {
            const nextElementsDiv = document.getElementById('nextElements');
            nextElementsDiv.innerHTML = '';
            
            nextElementsQueue.forEach(element => {
                const el = document.createElement('div');
                el.className = 'next-element';
                el.textContent = element;
                nextElementsDiv.appendChild(el);
            });
        }

        // Get the next element to place and refill the queue
        function getNextElementToPlace() {
            const elementToPlace = nextElementsQueue[0];
            
            // Shift the queue and add a new element
            nextElementsQueue.shift();
            nextElementsQueue.push(getRandomElement());
            
            updateNextElementsDisplay();
            return elementToPlace;
        }

        // Toggle X in a cell
        function toggleX(row, col, cellElement) {
            if (isAnimating) return; // Prevent clicks during animation
            if (mainGrid[row][col].type === ELEMENTS.EMPTY) {
                const elementToPlace = getNextElementToPlace();
                mainGrid[row][col] = {
                    type: elementToPlace,  // Start with first element
                    bonus: 0
                };
                updateCell(row, col);
                checkPossibleMerges(row, col, elementToPlace); 
            } 
        }

        // Check for possible merges
        function checkPossibleMerges(startRow, startCol, ELEMENT) {
            isAnimating = false; // Unlock animation
            if (mainGrid[startRow][startCol].type !== ELEMENT) return;

            const visited = new Set();
            const queue = [{ row: startRow, col: startCol }];
            const connected = [];

            while (queue.length > 0) {
                const { row, col } = queue.shift();
                const key = `${row},${col}`;
                if (visited.has(key)) continue;

                visited.add(key);
                connected.push({ row, col });

                const directions = [
                    { r: -1, c: 0 }, // Up
                    { r: 1, c: 0 },  // Down
                    { r: 0, c: -1 }, // Left
                    { r: 0, c: 1 }   // Right
                ];

                for (let dir of directions) {
                    const newRow = row + dir.r;
                    const newCol = col + dir.c;

                    if (
                        newRow >= 0 && newRow < gridSize &&
                        newCol >= 0 && newCol < gridSize &&
                        mainGrid[newRow][newCol].type === ELEMENT &&
                        !visited.has(`${newRow},${newCol}`)
                    ) {
                        queue.push({ row: newRow, col: newCol });
                    }
                }
            }

            if (connected.length >= 3) {
                connected.forEach(({ row, col }) => {
                    const cellEl = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
                    cellEl.classList.add(connected.length >= 4 ? 'bobble-strong' : 'bobble-light');
                });
            }

            if (connected.length >= MinConnections) {
                isAnimating = true; // Lock animation
                // Calculate total bonus from all merged cells
                let totalBonus = connected.reduce((sum, {row, col}) => {
                    return sum + mainGrid[row][col].bonus;
                }, 0);
                
                // Additional bonus from extra connections
                totalBonus += connected.length - MinConnections;

                // First pass: Clear all cells (starting from end)
                connected.slice().reverse().forEach(({ row, col }, index) => {
                    setTimeout(() => {
                        mainGrid[row][col] = {
                            type: ELEMENTS.EMPTY,
                            bonus: 0
                        };
                        let cellEl = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
                        cellEl.classList.remove('bobble-light', 'bobble-strong');
                        updateCell(row, col);
                    }, index * 100);
                });

                // Second pass: Convert first cell after all clears finish
                setTimeout(() => {
                    const first = connected[0];
                    const newType = getNextElement(ELEMENT);

                    mainGrid[first.row][first.col] = {
                        type: newType,
                        bonus: totalBonus
                    };
                    let cellEl = document.querySelector(`.grid-cell[data-row="${first.row}"][data-col="${first.col}"]`);
                    cellEl.classList.remove('bobble-light', 'bobble-strong');
                    updateCell(first.row, first.col);
                    
                    // Check for new possible merges (unless it's the final element)
                    if (ELEMENT_PROGRESSION.indexOf(newType) < ELEMENT_PROGRESSION.length - 1) {
                        checkPossibleMerges(first.row, first.col, newType);
                    }
                }, connected.length * 100);
                
                updateGrid();
            }
        }

        // Initialize on page load
        initializeGrid();
    </script>
</body>
</html>
